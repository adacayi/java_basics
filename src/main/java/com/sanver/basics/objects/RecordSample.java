package com.sanver.basics.objects;

import java.io.Serializable;
import java.util.Arrays;

public class RecordSample {
    /**
     * Demonstrates the use of Java Records, a feature introduced in Java 14 (preview) and fully in Java 16.
     * Records are a special kind of class in Java that are concise and immutable by default. They are ideal for
     * representing immutable data carriers without the need for boilerplate code.
     * <ul>
     * <li>Records are implicitly final, they cannot be extended.
     * Thus, the sealed hierarchy is even more concise with records, no need for the modifiers final,
     * sealed or non-sealed for a record extending a sealed interface, since it will be regarded as final.
     * <li>Records are immutable data classes that require only the type and name of fields.
     * <li>A record cannot extend a class but can implement interfaces.
     * <li>A record class is made serializable just like a normal class, simply by implementing {@link java.io.Serializable}.
     * <li>The {@code equals}, {@code hashCode} and {@code toString} methods, as well as the {@code private final} fields and public constructor are generated by the Java compiler.
     * </ul>
     * <p>Features demonstrated:
     * <ul>
     *   <li>The record {@code components} of a record class, if any, are specified in the header of a record declaration.</li>
     *   <li>Each record component consists of a type (optionally preceded by one or more annotations) and an identifier that specifies the name of the record component.</li>
     *   <li>A record component corresponds to two members of the record class: a private field declared implicitly, and a public accessor method declared explicitly or implicitly <a href = "https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.10.3">(§8.10.3)</a>.</li>
     *   <li>If a record class has no record components, then an empty pair of parentheses appears in the header of the record declaration.</li>
     *   <li><b>Automatic Generation of Accessor Methods</b>: Each component (field) of the record automatically has
     *       a public accessor method with the same name as the field.</li>
     *   <li><b>Compact Constructor</b>: Records support a compact constructor format for validation or
     *       additional processing when creating a record instance.</li>
     *   <li><b>Custom Static Methods</b>: You can add static utility methods to records.</li>
     *   <li><b>Custom Instance Methods</b>: Records support additional instance methods.</li>
     *   <li><b>Overriding {@code toString()}, {@code equals()}, and {@code hashCode()}</b>: Records automatically
     *       override these methods, but you can still customize them if needed.</li>
     *   <li><b>Java Reflection Support</b>: Records can be accessed through reflection, and you can retrieve
     *       record component metadata.</li>
     * </ul>
     * <a href = "https://www.baeldung.com/java-record-keyword">Source</a>
     */
    record Person(String name, int age, String... addresses) { // This is static by default and cannot access any instance members of its outer class (e.g. RecordSample.this.someMember won't compile)
        // We can have inner classes, enums, records and interfaces inside a record.
        private static final int DEFAULT_AGE = 30;
        public static String DEFAULT_NAME = "John"; // We can have final/non-final static fields with any access modifier (public, protected, private and package private) in a record.
//      public String address = ""; // This would result in a compile error. Instance fields are not allowed in records.

        static { // Note that non-static blocks are not allowed.
            System.out.println("Person initialized");
        }

        /**
         * Compact constructor to add validation logic when creating a new {@code Person} record.
         * For example, here it ensures the {@code age} is not negative.
         *
         * @param name      the name of the person
         * @param age       the age of the person, which must be non-negative
         * @param addresses the addresses of the person
         * @throws IllegalArgumentException if the age is negative
         */
        public Person {
            if (age < 0) {
                throw new IllegalArgumentException("Age cannot be negative");
            }
            // In a compact constructor, the constructor body is executed before the record's fields are assigned the values of the parameters.
            // After the constructor body runs, the fields are assigned the (possibly modified) values of the parameters.
//            System.out.println(this.age); // Although, in Java, instance fields are initialized to their default values before any constructor code runs,
//            for final fields, we cannot access their values before they are assigned in our code explicitly.
//            Thus, at this point this.age will result in a compile error: java: variable age might not have been initialized
//             this.age = age; // Note that we cannot assign the final field variables in the compact constructor. It will result in a compile error.  java: cannot assign a value to final variable age
            System.out.println("age(): " + age()); // This works fine and will always print 0, since in Java, instance fields are initialized to their default values before any constructor code runs
            // (but remember, we cannot directly access it with this.age), since age is final, but age() works.
            // For a non-final field in a class, we can access it directly as well and see its default value:
            // e.g.
            /*
            class Baby{
                int age; // If this was final, the `System.out.println(this.age)` in the constructor below would result in a compile error.

                Baby(int age) {
                    System.out.println(this.age); // Note that we can access this, since this.age is not final, and its value is the default value for int, which is 0.
                    this.age = age;
                }
            }*/
            System.out.println("age  : " + age); // This works fine and will always print the age value passed to the constructor.
            age += 100; // This is to show that the record fields are assigned the values of the compact constructor's parameters after the compact constructor's body is executed.
        }

        /**
         * This is to show constructor with different arguments
         *
         * @param age the age of the person
         */
        public Person(int age) {
            this(DEFAULT_NAME, age); // Note that the first line of every non-canonical constructor must be a call to another constructor, otherwise it will fail to compile (even if we assign values to the record components in the constructor body)
        }

//        Since we have the compact constructor, which has the same name and age arguments, we cannot have this constructor with the same arguments. Otherwise, this is possible as well.
//        public Person(String name, int age, String... addresses) {
//            this.name = name;
//            this.age = age;
//        }

        /**
         * Custom static method that returns a sample {@code Person} instance for demonstration.
         *
         * @return a {@code Person} instance with default values
         */
        public static Person defaultPerson() {
            return new Person(DEFAULT_NAME, DEFAULT_AGE);
        }

        /**
         * Demonstrates the {@code toString()} method generated by the record.
         * No need to override it unless a custom format is required.
         */
        public static void main(String[] args) {
            System.out.println("Serializable.class.isAssignableFrom(Person.class): " + Serializable.class.isAssignableFrom(Person.class)); // To show that by default, records don't implement Serializable. We need the record to implement serializable explicitly to be able to serialize it.
            Person person = new Person("Alice", 25);

            // Accessor methods
            System.out.println("Name: " + person.name()); // Accessing 'name' component
            System.out.println("Age: " + person.age());   // Accessing 'age' component

            // Compact constructor ensures age is non-negative
            // Uncommenting the following line would throw an IllegalArgumentException
            // Person invalidPerson = new Person("Bob", -5);

            // Using a static method to get a default person
            Person defaultPerson = Person.defaultPerson();
            System.out.println("Default Person: " + defaultPerson);

            // Checking custom instance method
            System.out.println("Is adult: " + person.isAdult());

            // Demonstrating auto-generated toString(), equals(), and hashCode()
            System.out.println("Person toString: " + person); // toString is automatically generated
            System.out.println("Equal to default person: " + person.equals(defaultPerson));
            var newPerson = new Person("Alice", 25);
            System.out.printf("Equal to newPerson %s: %s%n", newPerson, person.equals(newPerson)); // Notice the equals method checks for equality of each field in the record, instead of a basic object equality
            System.out.printf("%-20s: %,d%n", "person.hashCode()", person.hashCode());
            System.out.printf("%-20s: %,d%n", "newPerson.hashCode()", newPerson.hashCode());

            // person.age = 12; // The age field is private and final. We cannot change its value, thus this line would result in a compile error.
            // This is just to demonstrate that static non-final fields in a record can be changed.
            Person.DEFAULT_NAME = "MIKE";
            System.out.println(new Person(12));
            System.out.println(new Person(12).addresses().length);
            System.out.println(new Person("Janet", 28).addresses().length);
            System.out.println(Arrays.toString(new Person("Harry", 30, "Street1", "Street2").addresses()));

            // Showing a record with no fields
            var dummy1 = new Dummy();
            var dummy2 = new Dummy();
            System.out.printf("dummy1: %s dummy2: %s, dummy1.hashCode(): %d, dummy2.hashCode(): %d, dummy1.equals(dummy2): %s%n", dummy1, dummy2, dummy1.hashCode(), dummy2.hashCode(), dummy1.equals(dummy2));
        }

        /**
         * Custom instance method to check if the person is considered an adult.
         *
         * @return {@code true} if age is 18 or older, {@code false} otherwise
         */
        public boolean isAdult() {
            return age >= 18;
        }

        private class SomeClass{ } // We can define inner classes, static classes, abstract classes, interfaces, enums and records in a record with any access modifiers.

        protected static class SomeStaticClass{}

        private abstract class SomeAbstractClass{}

        protected interface SomeInterface{}

        protected enum SomeEnum{}

        private record SomeRecord(){}
    }

    record Dummy(){} // This is a valid record definition with no components.
}
