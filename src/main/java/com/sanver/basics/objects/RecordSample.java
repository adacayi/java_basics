package com.sanver.basics.objects;

import java.io.Serializable;
import java.util.Arrays;

public class RecordSample {
    /**
     * Demonstrates the use of Java Records, a feature introduced in Java 14 (preview) and fully in Java 16.
     * Records are a special kind of class in Java that are concise and immutable by default. They are ideal for
     * representing immutable data carriers without the need for boilerplate code.
     * <ul>
     * <li>Records are implicitly final, they cannot be extended.
     * Thus, the sealed hierarchy is even more concise with records, no need for the modifiers final,
     * sealed or non-sealed for a record extending a sealed interface, since it will be regarded as final.
     * <li>Records are immutable data classes that require only the type and name of fields.
     * <li>A record cannot extend a class but can implement interfaces.
     * <li>A record class is made serializable just like a normal class, simply by implementing {@link java.io.Serializable}.
     * <li>The {@code equals}, {@code hashCode} and {@code toString} methods, as well as the {@code private final} fields and public constructor are generated by the Java compiler.
     * </ul>
     * <p>Features demonstrated:
     * <ul>
     *   <li><b>Automatic Generation of Accessor Methods</b>: Each component (field) of the record automatically has
     *       a public accessor method with the same name as the field.</li>
     *   <li><b>Compact Constructor</b>: Records support a compact constructor format for validation or
     *       additional processing when creating a record instance.</li>
     *   <li><b>Custom Static Methods</b>: You can add static utility methods to records.</li>
     *   <li><b>Custom Instance Methods</b>: Records support additional instance methods.</li>
     *   <li><b>Overriding {@code toString()}, {@code equals()}, and {@code hashCode()}</b>: Records automatically
     *       override these methods, but you can still customize them if needed.</li>
     *   <li><b>Java Reflection Support</b>: Records can be accessed through reflection, and you can retrieve
     *       record component metadata.</li>
     * </ul>
     * <a href = "https://www.baeldung.com/java-record-keyword">Source</a>
     */
    record Person(String name, int age, String... addresses) {
        private static final int DEFAULT_AGE = 30;
        public static String DEFAULT_NAME = "John"; // We can have final/non-final static fields with any access modifier (public, protected, private and package private) in a record.
//      public String address = ""; // This would result in a compile error. Instance fields are not allowed in records.

        /**
         * Compact constructor to add validation logic when creating a new {@code Person} record.
         * For example, here it ensures the {@code age} is not negative.
         *
         * @param name      the name of the person
         * @param age       the age of the person, which must be non-negative
         * @param addresses the addresses of the person
         * @throws IllegalArgumentException if the age is negative
         */
        public Person {
            if (age < 0) {
                throw new IllegalArgumentException("Age cannot be negative");
            }
//            System.out.println(this.age); // This will result in a compile error. java: variable age might not have been initialized
//             this.age = age; // Note that we do not need to and cannot assign the final field variables in the compact constructor. It will result in a compile error.  java: cannot assign a value to final variable age
            System.out.println("age(): " + age()); // This works fine and will always print 0 indicating that at this stage the final field values are not assigned to their values.
            System.out.println("age  : " + age); // This works fine and will always print the age value passed to the constructor.
        }

        /**
         * This is to show constructor with different arguments
         *
         * @param age the age of the person
         */
        public Person(int age) {
            this(DEFAULT_NAME, age);
        }

//        Since we have the compact constructor, which has the same name and age arguments, we cannot have this constructor with the same arguments. Otherwise, this is possible as well.
//        public Person(String name, int age, String... addresses) {
//            this.name = name;
//            this.age = age;
//        }

        /**
         * Custom static method that returns a sample {@code Person} instance for demonstration.
         *
         * @return a {@code Person} instance with default values
         */
        public static Person defaultPerson() {
            return new Person(DEFAULT_NAME, DEFAULT_AGE);
        }

        /**
         * Demonstrates the {@code toString()} method generated by the record.
         * No need to override it unless a custom format is required.
         */
        public static void main(String[] args) {
            System.out.println("Serializable.class.isAssignableFrom(Person.class): " + Serializable.class.isAssignableFrom(Person.class)); // To show that by default, records don't implement Serializable. We need the record to implement serializable explicitly to be able to serialize it.
            Person person = new Person("Alice", 25);

            // Accessor methods
            System.out.println("Name: " + person.name()); // Accessing 'name' component
            System.out.println("Age: " + person.age());   // Accessing 'age' component

            // Compact constructor ensures age is non-negative
            // Uncommenting the following line would throw an IllegalArgumentException
            // Person invalidPerson = new Person("Bob", -5);

            // Using a static method to get a default person
            Person defaultPerson = Person.defaultPerson();
            System.out.println("Default Person: " + defaultPerson);

            // Checking custom instance method
            System.out.println("Is adult: " + person.isAdult());

            // Demonstrating auto-generated toString(), equals(), and hashCode()
            System.out.println("Person toString: " + person); // toString is automatically generated
            System.out.println("Equal to default person: " + person.equals(defaultPerson));
            var newPerson = new Person("Alice", 25);
            System.out.printf("Equal to newPerson %s: %s%n", newPerson, person.equals(newPerson)); // Notice the equals method checks for equality of each field in the record, instead of a basic object equality
            System.out.printf("%-20s: %,d%n", "person.hashCode()", person.hashCode());
            System.out.printf("%-20s: %,d%n", "newPerson.hashCode()", newPerson.hashCode());

            // person.age = 12; // The age field is private and final. We cannot change its value, thus this line would result in a compile error.
            // This is just to demonstrate that static non-final fields in a record can be changed.
            Person.DEFAULT_NAME = "MIKE";
            System.out.println(new Person(12));
            System.out.println(new Person(12).addresses().length);
            System.out.println(new Person("Janet", 28).addresses().length);
            System.out.println(Arrays.toString(new Person("Harry", 30, "Street1", "Street2").addresses()));
        }

        /**
         * Custom instance method to check if the person is considered an adult.
         *
         * @return {@code true} if age is 18 or older, {@code false} otherwise
         */
        public boolean isAdult() {
            return age >= 18;
        }
    }

}
